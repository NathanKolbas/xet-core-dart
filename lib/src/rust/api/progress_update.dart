// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'progress_update.freezed.dart';
part 'progress_update.g.dart';

// These functions are ignored because they are not marked as `pub`: `register_updates_impl`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `WrappedProgressUpdaterImpl`, `WrappedProgressUpdater`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `register_updates`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `new`, `new`

/// Dart-exposed versions of the per-item and total progress update classes.
///
/// Both `DartTotalProgressUpdate` and `DartItemProgressUpdate` are passed
/// into a Dart callback given to the wrapper class below.  For example (in python):
///
/// ```python
/// def update_progress(self, total_update, item_updates):
///     from rich.progress import Progress, TextColumn, BarColumn, TimeRemainingColumn
///
///     # Update overall progress (we assume this has been initialized).
///     self.progress.update(
///         self.bytes_processed_task_id,
///         advance=total_update.total_bytes_completion_increment,
///         total = total_update.total_bytes
///     )
///
///     # Update upload progress ; the total may have changed so set that too.
///     self.progress.update(
///         self.bytes_uploaded_task_id,
///         advance=total_update.total_transfer_bytes_completion_increment,
///         total = total_update.total_transfer_bytes
///     )
///
///     # Update each item:
///     for item in item_updates:
///         name = item.item_name
///         if name not in self.item_tasks:
///             self.item_tasks[name] = self.progress.add_task(
///                 name, total=item.total_bytes
///             )
///         self.progress.update(
///             self.item_tasks[name],
///             advance=item.bytes_completion_increment,
///         )
/// ```
///
/// In addition, the other possible bookkeeping values for everything are contained in this
/// as needed.
@freezed
sealed class DartItemProgressUpdate with _$DartItemProgressUpdate {
  const factory DartItemProgressUpdate({
    required String itemName,
    required BigInt totalBytes,
    required BigInt bytesCompleted,
    required BigInt bytesCompletionIncrement,
  }) = _DartItemProgressUpdate;

  factory DartItemProgressUpdate.fromJson(Map<String, dynamic> json) =>
      _$DartItemProgressUpdateFromJson(json);
}

/// Update class for total updates
@freezed
sealed class DartTotalProgressUpdate with _$DartTotalProgressUpdate {
  const factory DartTotalProgressUpdate({
    required BigInt totalBytes,
    required BigInt totalBytesIncrement,
    required BigInt totalBytesCompleted,
    required BigInt totalBytesCompletionIncrement,
    double? totalBytesCompletionRate,
    required BigInt totalTransferBytes,
    required BigInt totalTransferBytesIncrement,
    required BigInt totalTransferBytesCompleted,
    required BigInt totalTransferBytesCompletionIncrement,
    double? totalTransferBytesCompletionRate,
  }) = _DartTotalProgressUpdate;

  factory DartTotalProgressUpdate.fromJson(Map<String, dynamic> json) =>
      _$DartTotalProgressUpdateFromJson(json);
}
